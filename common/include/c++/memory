#ifndef __MEMORY
#define __MEMORY
#include "bits/stl_allocator.h"
#include "concepts"
#include "bits/move.h"
namespace std
{
    template<typename T>
    struct allocator : __base_allocator<T>
    {
        typedef T value_type;
        typedef T* pointer;
        typedef typename std::pointer_traits<pointer>::rebind<const value_type> const_pointer;
        typedef typename std::pointer_traits<pointer>::rebind<void> void_pointer;
        typedef typename std::pointer_traits<pointer>::rebind<const void> const_void_pointer;
        typedef true_type propagate_on_container_move_assignment;
        typedef decltype(sizeof(T)) size_type;
        typedef decltype(declval<pointer>() - declval<pointer>()) difference_type;
        constexpr allocator() noexcept = default;
        constexpr allocator(allocator const&) noexcept = default;
        template<typename U> constexpr allocator(allocator<U> const&) noexcept {};
        constexpr ~allocator() noexcept = default;
        [[nodiscard]] constexpr pointer allocate(size_type count) const { return this->__allocate(count); }
        constexpr void deallocate(pointer ptr, size_type count) const { this->__deallocate(ptr, count); }
    };
    template<typename T, typename U> constexpr bool operator==(allocator<T> const&, allocator<U> const&) noexcept { return true; }
    template<typename T, typename ... Args> requires __detail::__dynamic_constructible<T, Args...> constexpr T* construct_at(T* ptr, Args ... args) { if constexpr(std::is_array_v<T>) return ::new (static_cast<void*>(ptr)) T[1](); else return ::new (static_cast<void*>(ptr)) T { std::forward<Args>(args) ... }; }
    // More as needed
}
#endif
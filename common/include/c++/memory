#ifndef __MEMORY
#define __MEMORY
#include "bits/stl_allocator.h"
#include "concepts"
#include "bits/move.h"
namespace std
{
    template<typename T>
    struct allocator : __base_allocator<T>
    {
        typedef T value_type;
        typedef true_type propagate_on_container_move_assignment;
        using size_type = decltype(sizeof(T));
        using difference_type = decltype(__detail::__null__<T>() - __detail::__null__<T>());
        constexpr allocator() noexcept = default;
        constexpr allocator(allocator const&) noexcept = default;
        template<typename U> constexpr allocator(allocator<U> const&) noexcept {};
        constexpr ~allocator() noexcept = default;
        [[nodiscard]] constexpr T* allocate(size_type count) { return this->__allocate(count); }
        constexpr void deallocate(T* ptr, size_type count) { this->__deallocate(ptr, count); }
    };
    template<typename T> concept __non_array = !std::is_array_v<T>;
    template<typename ... Args> concept __zero_size = sizeof...(Args) == 0;
    template<typename T, typename ... Args> concept __dynamic_constructible = std::constructible_from<T, Args...> && (__non_array<T> || __zero_size<Args...>);
    template<typename T, typename U> constexpr bool operator==(allocator<T> const&, allocator<U> const&) noexcept { return true; }
    template<typename T, typename ... Args> requires __dynamic_constructible<T, Args...> constexpr T* construct_at(T* ptr, Args ... args) { if constexpr(std::is_array_v<T>) return ::new (static_cast<void*>(ptr)) T[1](); else return ::new (static_cast<void*>(ptr)) T { std::forward<Args>(args) ... }; }
    // More as needed
}
#endif
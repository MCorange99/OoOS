#ifndef __TUPLE
#define __TUPLE
#include "bits/move.h"
#include "concepts"
namespace std
{
    template<size_t... Is> struct __index_tuple { };
    template<size_t N> struct __build_index_tuple { using __type = __index_tuple<__integer_pack(N)...>; };
    template< class... Ts > class tuple;
    template<size_t I, class T>
    struct tuple_element;
    template<size_t I, typename HT>
    struct __head_base
    {
        HT __my_obj;
        constexpr __head_base(__head_base const&) = default;
        constexpr __head_base(__head_base&&) = default;
        constexpr __head_base(HT const& h) : __my_obj{ h }{}
        constexpr __head_base() : __my_obj{} {}
        template<typename GT> constexpr __head_base(GT const& h) : __my_obj{ std::forward<GT>(h) }{}
        constexpr static HT& __head(__head_base & _h) noexcept { return _h.__my_obj; }
        constexpr static HT const& __head(__head_base const& _h) noexcept { return _h.__my_obj; }
    };
    template<size_t I, typename ...ETs> struct __tuple_impl;
    template<size_t I, typename HT>
    struct __tuple_impl<I, HT> : private __head_base<I, HT>
    {
        template<size_t, typename...> friend struct __tuple_impl;
        using __base = __head_base<I, HT>;
        constexpr __tuple_impl() : __base() {}
        constexpr __tuple_impl(HT const& h) : __base{h}{}
        template<typename GT>
        constexpr explicit __tuple_impl(GT const& h) : __base{std::forward<GT>(h)}{}
        constexpr __tuple_impl(__tuple_impl const&) = default;
        constexpr __tuple_impl(__tuple_impl&&) = default;
        static constexpr HT& __head(__tuple_impl& t) noexcept { return __base::__head(t);}
        static constexpr HT const& __head(__tuple_impl const& t) noexcept {return __base::__head(t);}
    };
    template<size_t I, typename HT, typename ...ETs>
    struct __tuple_impl<I, HT, ETs...> : public __tuple_impl<I + 1, ETs...>, private __head_base<I, HT>
    {
        template<size_t, typename...> friend struct __tuple_impl;
        using __base = __head_base<I, HT>;
        using __next = __tuple_impl<I + 1, ETs...>;
        static constexpr HT& __head(__tuple_impl& t) noexcept { return __base::__head(t); }
        static constexpr HT const& __head(__tuple_impl const& t) noexcept { return __base::__head(t); }
        static constexpr ETs& __tail(__tuple_impl& t) noexcept { return t; }
        static constexpr ETs const& __tail(__tuple_impl const& t) noexcept { return t; }
        constexpr __tuple_impl() : __base{}, __next{} {}
        constexpr explicit __tuple_impl(HT const& h, ETs const&... t) : __base{h}, __next{t...} {}
        template<typename ...FTs> constexpr void __assign(__tuple_impl<I, FTs> const& that) { __head(*this) = __tuple_impl<I, FTs...>::__head(that); __tail(*this).__assign(__tuple_impl<I, FTs...>::__tail(that)); }
        template<typename UHead, typename ...UTails> constexpr void __assign(__tuple_impl<I, UHead, UTails...>&& that) { __head(*this) = __tuple_impl<I, UHead, UTails...>::__head(that); __tail(*this).__assign(std::move(__tuple_impl<I, UHead, UTails...>::__tail(that))); }
    protected:
        constexpr void __swap(__tuple_impl& that) { using std::swap; swap(__head(*this), __head(that)); __next::__swap(__tail(that)); }
    };
    template<typename ... Ts>
    struct __tuple_constraints
    {
        template<typename... Us> using __constructible = __and_<is_constructible<Ts, Us>...>;
        template<typename... Us> using __convertible = __and_<is_convertible<Us, Ts>...>;
        template<typename... Us> constexpr static bool __is_implicitly_constructible() { return __and_<__constructible<Us...>, __convertible<Us...>>::value; }
        template<typename... Us> constexpr static bool __is_explicitly_constructible() { return __and_<__constructible<Us...>, __not_<__convertible<Us...>> >::value; }
        constexpr static bool __is_implicitly_default_constructible() { return __and_<std::__is_implicitly_default_constructible<Ts>...>::value; }
        constexpr static bool __is_explicitly_default_constructible() { return __and_<is_default_constructible<Ts>..., __not_<__and_<std::__is_implicitly_default_constructible<Ts>...>>>::value; }
    };
    template<typename ...ETs>
    class tuple : public __tuple_impl<0, ETs...> 
    {
        typedef __tuple_impl<0, ETs...> __base;
        typedef __tuple_constraints<ETs...> __constraints;
        template<typename... FTs> static constexpr bool __nothrow_constructible() { return __and_<is_nothrow_constructible<ETs, FTs>...>::value; }
        template<typename U> static constexpr bool __valid_args() { return sizeof...(ETs) == 1 && !is_same_v<tuple, __remove_cvref_t<U>>; }
        template<typename, typename, typename ... TTs> static constexpr bool __valid_args() { return (2 + sizeof...(TTs) == sizeof...(ETs)); }
        template<typename TLT, typename = tuple, typename = __remove_cvref_t<TLT>> struct __use_other_ctor : false_type {};
        template<typename TLT, typename T, typename U> struct __use_other_ctor<TLT, tuple<T>, tuple<U>> : __or_<is_convertible<TLT, T>, is_constructible<T, TLT>>::type {};
        template<typename TLT, typename T> struct __use_other_ctor<TLT, tuple<T>, tuple<T>> : true_type  {};
        template<typename TLT> static constexpr bool __use_other_ctor() { return __use_other_ctor<TLT>::value; }
        template<typename ... FTs> requires (sizeof...(FTs) == sizeof...(ETs)) static constexpr bool __assignable() { return __and_<is_assignable<ETs&, FTs>...>::value; }
        template<typename ... FTs> static constexpr bool __nothrow_assignable() { return __and_<is_nothrow_assignable<ETs&, FTs>...>::value; }
        template<__detail::__boolean_testable DB> constexpr static bool __implicit_default_ctor() { if constexpr(DB{}) return __constraints::__is_implicitly_default_constructible(); else return false; }
        template<__detail::__boolean_testable DB> constexpr static bool __explicit_default_ctor() { if constexpr(DB{}) return __constraints::__is_explicitly_default_constructible(); else return false; }
        template<__detail::__boolean_testable DB, typename ... Args> constexpr static bool __implicit_ctor() { if constexpr(DB{}) return __constraints::template __is_implicitly_constructible<Args...>(); else return false; }
        template<__detail::__boolean_testable DB, typename ... Args> constexpr static bool __explicit_ctor() { if constexpr(DB{}) return __constraints::template __is_explicitly_constructible<Args...>(); else return false; }
        struct __not_empty : bool_constant<sizeof...(ETs) >= 1> {};
        template<typename ... TTs> struct __valid : bool_constant<__valid_args<TTs...>()>{};
    public:
        template<typename DT = void> requires (__implicit_default_ctor<is_void<DT>>())
        constexpr tuple() noexcept(__and_v<is_nothrow_default_constructible<ETs>...>) : __base{} {}
        template<typename DT = void> requires (__explicit_default_ctor<is_void<DT>>())
        constexpr explicit tuple() noexcept(__and_v<is_nothrow_default_constructible<ETs>...>) : __base{} {}
        constexpr tuple(ETs const& ... elements) noexcept(__nothrow_constructible<ETs const&...>) 
        requires(__implicit_ctor<__not_empty, ETs const&...>()) : __base{ elements... } {}
        constexpr explicit tuple(ETs const& ... elements) noexcept(__nothrow_constructible<ETs const&...>) 
        requires(__explicit_ctor<__not_empty, ETs const&...>()) : __base{ elements... } {}
        template<typename ... FTs> requires (__implicit_ctor<__valid<FTs...>, FTs...>())
        constexpr tuple(FTs const& ... elements) : __base{ elements }{}
        constexpr tuple(const tuple&) = default;
        constexpr tuple(tuple&&) = default;
                tuple& operator=(conditional_t<__assignable<ETs const&...>(), tuple const&, __nonesuch const&> that)
        noexcept(__nothrow_assignable<ETs const&...>())
        {
            this->__assign(that);
            return *this;
        }
        tuple& operator=(conditional_t<__assignable<ETs...>(), tuple&&, __nonesuch&&> that)
        noexcept(__nothrow_assignable<ETs...>())
        {
            this->__assign(std::move(that));
            return *this;
        }
    };
        template<>
    class tuple<>
    {
    public:
        constexpr void swap(tuple const&){}
        constexpr tuple() = default;
    };
    template<template<typename...> class TRT, typename T, typename TLT> inline constexpr bool __unpack_std_tuple = false;
    template<template<typename...> class TRT, typename T, typename... U> inline constexpr bool __unpack_std_tuple<TRT, T, tuple<U...>> = TRT<T, U...>::value;
    template<template<typename...> class TRT, typename T, typename... U> inline constexpr bool __unpack_std_tuple<TRT, T, tuple<U...>&> = TRT<T, U&...>::value;
    template<template<typename...> class TRT, typename T, typename... U> inline constexpr bool __unpack_std_tuple<TRT, T, const tuple<U...>> = TRT<T, const U...>::value;
    template<template<typename...> class TRT, typename T, typename... U>  inline constexpr bool __unpack_std_tuple<TRT, T, const tuple<U...>&> = TRT<T, const U&...>::value; 
    template<size_t I, class T> struct tuple_element; 
    template<size_t I, class T>
    struct tuple_element<I, const T> { using type = typename add_const<typename tuple_element<I, T>::type>::type; };
    template<class T> struct tuple_size;
    template<class T> struct tuple_size< const T > : integral_constant<size_t, tuple_size<T>::value> {};
    template<class ... Ts> struct tuple_size<tuple<Ts...>> : integral_constant<size_t, sizeof...(Ts)> {};
    template<size_t I, class HT, class... ETs> struct tuple_element<I, tuple<HT, ETs...>> : tuple_element<I - 1, tuple<ETs...>>{};
    template<class HT, class... ETs> struct tuple_element<0, tuple<HT, ETs...>>  { using type = HT; };
    template<size_t I, typename HT, typename ...ETs> constexpr HT& __get_helper(__tuple_impl<I, HT, ETs...>& t) { return __tuple_impl<I, HT, ETs...>::__head(t); }
    template<size_t I, typename HT, typename ...ETs> constexpr HT const& __get_helper(__tuple_impl<I, HT, ETs...> const& t) { return __tuple_impl<I, HT, ETs...>::__head(t); }
    template<size_t I, typename ...ETs> using __elem_t = typename tuple_element<I, tuple<ETs...>>::type;
    template<size_t I, typename ...ETs> constexpr __elem_t <I, ETs...> const& get(tuple<ETs...> const& t) noexcept  { return __get_helper<I>(t); }
    template<size_t I, typename ...ETs> constexpr __elem_t<I, ETs...>& get(tuple<ETs...>& t) noexcept { return __get_helper<I>(t); }
    template<size_t I, typename... ETs> constexpr __elem_t<I, ETs...>&& get(tuple<ETs...>&& t) noexcept { return std::forward<__elem_t>(__get_helper<I>(t)); }
    template<size_t I, typename... ETs> constexpr const __elem_t<I, ETs...>&& get(const tuple<ETs...>&& t) noexcept { return std::forward<__elem_t>(__get_helper<I>(t)); }
}
#endif